/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package rosetta.db

import com.sun.nio.file.ExtendedOpenOption
import mu.KotlinLogging
import java.io.File
import java.lang.foreign.MemorySegment
import java.lang.foreign.MemorySession
import java.lang.foreign.ValueLayout
import java.nio.channels.FileChannel
import java.nio.file.OpenOption
import java.nio.file.Path
import java.nio.file.StandardOpenOption
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.locks.ReentrantReadWriteLock
import kotlin.experimental.and
import kotlin.experimental.or

const val PAGE_SIZE = 4096
const val BUFFER_POOL_PAGES = 1000

object Constants {
    val JAVA_SHORT_UNALIGNED = ValueLayout.JAVA_SHORT.withBitAlignment(8)
    val JAVA_INT_UNALIGNED = ValueLayout.JAVA_INT.withBitAlignment(8)
    val JAVA_LONG_UNALIGNED = ValueLayout.JAVA_LONG.withBitAlignment(8)
}

data class TableLocation(
    val dbId: Int,
    val tableId: Int
)

data class PageLocation(
    val dbId: Int,
    val tableId: Int,
    val pageId: Int
)

data class RecordId(
    val pageId: Int,
    val slotId: Int
)

interface IDiskManager {
    fun getDatabaseDirectory(dbId: Int): Path
    fun createDatabaseDirectory(dbId: Int): Path
    fun removeDatabaseDirectory(dbId: Int): Boolean

    fun getTableFilePath(tableLocation: TableLocation): Path
    fun createTableFile(tableLocation: TableLocation): Path
    fun removeTableFile(tableLocation: TableLocation): Boolean
    fun openTableFile(tableLocation: TableLocation): FileChannel

    fun readPage(pageLocation: PageLocation, page: MemorySegment)
    fun writePage(pageLocation: PageLocation, page: MemorySegment)

    fun getNumPages(tableLocation: TableLocation): Int
    fun allocatePage(tableLocation: TableLocation): Int
}

object DiskManager : IDiskManager {
    // The root of the database directory
    const val DB_ROOT = "/tmp/mini-sql-engine"
    private val logger = KotlinLogging.logger {}

    private val fcCache = ConcurrentHashMap<TableLocation, FileChannel>()
    private val OPEN_OPTIONS: Set<OpenOption> =
        setOf(StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE, ExtendedOpenOption.DIRECT)


    override fun getDatabaseDirectory(dbId: Int): Path {
        return Path.of(DB_ROOT, "db_$dbId")
    }

    override fun getTableFilePath(tableLocation: TableLocation): Path {
        return Path.of(DB_ROOT, "db_${tableLocation.dbId}", "table_${tableLocation.tableId}")
    }


    // Gets the file for a table, creating the directory if it doesn't exist
    private fun getOrCreateTableFile(tableLocation: TableLocation): FileChannel {
        return fcCache.computeIfAbsent(tableLocation) {
            val tablePath = getTableFilePath(tableLocation)
            // Create the directory if it doesn't exist
            tablePath.parent.toFile().mkdirs()
            FileChannel.open(tablePath, OPEN_OPTIONS)
        }
    }

    override fun createDatabaseDirectory(dbId: Int): Path {
        logger.info { "Creating database directory for dbId $dbId" }
        val dbPath = getDatabaseDirectory(dbId)
        if (!dbPath.toFile().exists()) {
            dbPath.toFile().mkdirs()
        }
        return dbPath
    }

    override fun removeDatabaseDirectory(dbId: Int): Boolean {
        logger.info { "Removing database directory for dbId $dbId" }
        val dbPath = getDatabaseDirectory(dbId)
        return dbPath.toFile().deleteRecursively()
    }

    override fun createTableFile(tableLocation: TableLocation): Path {
        logger.info { "Creating table file for table $tableLocation" }
        val tablePath = getTableFilePath(tableLocation)
        if (!tablePath.toFile().exists()) {
            tablePath.toFile().createNewFile()
        }
        return tablePath
    }

    override fun removeTableFile(tableLocation: TableLocation): Boolean {
        logger.info { "Removing table file for table $tableLocation" }
        val tablePath = getTableFilePath(tableLocation)
        return tablePath.toFile().delete()
    }

    override fun openTableFile(tableLocation: TableLocation): FileChannel {
        logger.info { "Opening table file for table $tableLocation" }
        return getOrCreateTableFile(tableLocation)
    }

    override fun readPage(pageLocation: PageLocation, page: MemorySegment) {
        logger.info { "Reading page $pageLocation" }
        val fc = getOrCreateTableFile(TableLocation(pageLocation.dbId, pageLocation.tableId))
        val alignedBuffer = page.asByteBuffer().alignedSlice(PAGE_SIZE)  // Align to PAGE_SIZE for Direct I/O (O_DIRECT)
        val readBytes = fc.read(alignedBuffer, pageLocation.pageId * PAGE_SIZE.toLong())
        logger.info { "Read $readBytes bytes" }
        // Special case for empty files, fill the buffer with 0's
        if (readBytes == 0) {
            page.fill((0).toByte())
            return
        }
        if (readBytes != PAGE_SIZE) {
            throw IllegalStateException("Read $readBytes bytes, expected $PAGE_SIZE")
        }
    }

    override fun writePage(pageLocation: PageLocation, page: MemorySegment) {
        logger.info { "Writing page $pageLocation" }
        val fc = getOrCreateTableFile(TableLocation(pageLocation.dbId, pageLocation.tableId))
        val alignedBuffer = page.asByteBuffer().alignedSlice(PAGE_SIZE) // Align to PAGE_SIZE for Direct I/O (O_DIRECT)
        val writtenBytes = fc.write(alignedBuffer, pageLocation.pageId * PAGE_SIZE.toLong())
        logger.info { "Wrote $writtenBytes bytes" }
    }

    // TODO: Should this be named "getNumPagesZeroIndexed"?
    override fun getNumPages(tableLocation: TableLocation): Int {
        logger.info { "Getting number of pages for table $tableLocation" }
        val fc = getOrCreateTableFile(tableLocation)
        val numPages = (fc.size() / PAGE_SIZE).toInt()
        // TODO: This feels gross, revisit this if you get a better idea
        return when (numPages) {
            0 -> 0
            else -> numPages - 1 // Pages are 0-indexed
        }
    }

    override fun allocatePage(tableLocation: TableLocation): Int {
        logger.info { "Allocating page for table $tableLocation" }
        val fc = getOrCreateTableFile(tableLocation)
        val newPageId = getNumPages(tableLocation)
        val emptyBuffer = MemorySegment.allocateNative(PAGE_SIZE.toLong(), MemorySession.global())
        val alignedBuffer = emptyBuffer.asByteBuffer().alignedSlice(PAGE_SIZE)
        fc.write(alignedBuffer)
        return newPageId
    }
}


// Eviction policy interface for the buffer pool
// Has callback methods for when a page is pinned or unpinned
// The eviction policy should implement the logic for which page to evict
interface IEvictionPolicy {
    fun pagePinned(pageId: Int)
    fun pageUnpinned(pageId: Int)
    fun evictPage(): Int
}

// LRU eviction policy
class LRUEvictionPolicy : IEvictionPolicy {
    private val logger = KotlinLogging.logger {}

    private val pageIds = ArrayDeque<Int>()

    override fun pagePinned(pageId: Int) {
        logger.info { "Page $pageId pinned" }
        pageIds.remove(pageId)
        pageIds.addLast(pageId)
    }

    override fun pageUnpinned(pageId: Int) {
        logger.info { "Page $pageId unpinned" }
        pageIds.remove(pageId)
        pageIds.addFirst(pageId)
    }

    override fun evictPage(): Int {
        logger.info { "Evicting page" }
        return pageIds.removeFirst()
    }
}

class ClockEvictionPolicy : IEvictionPolicy {
    private val logger = KotlinLogging.logger {}

    private var clockHand = 0
    private val refBit = BooleanArray(BUFFER_POOL_PAGES)

    override fun pagePinned(pageId: Int) {
        logger.info { "Page $pageId pinned" }
        refBit[pageId] = true
    }

    override fun pageUnpinned(pageId: Int) {
        logger.info { "Page $pageId unpinned" }
        refBit[pageId] = false
    }

    override fun evictPage(): Int {
        logger.info { "Evicting page" }
        while (true) {
            if (!refBit[clockHand]) {
                val pageId = clockHand
                clockHand = (clockHand + 1) % BUFFER_POOL_PAGES
                return pageId
            }
            refBit[clockHand] = false
            clockHand = (clockHand + 1) % BUFFER_POOL_PAGES
        }
    }
}

interface IBufferPool {
    fun fetchPage(pageLocation: PageLocation): MemorySegment
    fun unpinPage(pageLocation: PageLocation, isDirty: Boolean)
    fun flushPage(pageLocation: PageLocation)
    fun flushAllPages(dbId: Int)

    // Run an action using a page from the buffer pool. Calls "fetchPage" and "unpinPage" automatically
    // The "isDirty" flag is passed to "unpinPage" with the boolean returned by the action
    fun <T> withPage(pageLocation: PageLocation, action: (MemorySegment) -> Pair<T, Boolean>): T {
        fetchPage(pageLocation)
        val (result, isDirty) = action(fetchPage(pageLocation))
        unpinPage(pageLocation, isDirty)
        return result
    }

    fun <T> withPage(pageLocation: PageLocation, willDirty: Boolean = false, action: (MemorySegment) -> T): T {
        return withPage(pageLocation) { page -> Pair(action(page), willDirty) }
    }
}

fun <T> ReentrantReadWriteLock.withReadLock(action: () -> T): T {
    this.readLock().lock()
    try {
        return action()
    } finally {
        this.readLock().unlock()
    }
}

fun <T> ReentrantReadWriteLock.withWriteLock(action: () -> T): T {
    this.writeLock().lock()
    try {
        return action()
    } finally {
        this.writeLock().unlock()
    }
}

class BufferPool(
    private val diskManager: IDiskManager,
    private val evictionPolicy: IEvictionPolicy
) : IBufferPool {
    private val logger = KotlinLogging.logger {}

    private val bufferPool: MemorySegment
    private val pages: Array<MemorySegment>
    private val freeList: ArrayDeque<Int>

    private val pinCount = IntArray(BUFFER_POOL_PAGES)
    private val isDirty = BooleanArray(BUFFER_POOL_PAGES)
    private val refBit = BooleanArray(BUFFER_POOL_PAGES)
    private val pageTable = HashMap<PageLocation, Int>()
    private val pageTableRwLock = ReentrantReadWriteLock()

    init {
        bufferPool = MemorySegment.allocateNative(PAGE_SIZE * BUFFER_POOL_PAGES.toLong(), MemorySession.global())
        pages = Array(BUFFER_POOL_PAGES) { bufferPool.asSlice((it * PAGE_SIZE).toLong(), PAGE_SIZE.toLong()) }
        freeList = ArrayDeque((0 until BUFFER_POOL_PAGES).toList())
    }

    private fun pinPage(pageLocation: PageLocation) {
        logger.info { "Pinning page $pageLocation" }
        val pageId = pageTableRwLock.withReadLock {
            pageTable[pageLocation]
        }
        if (pageId != null) {
            pinCount[pageId]++
            refBit[pageId] = true
            evictionPolicy.pagePinned(pageId)
        }
    }

    override fun fetchPage(pageLocation: PageLocation): MemorySegment {
        logger.info { "Fetching page $pageLocation" }
        // First, check if the page is already in the buffer pool
        val pageId = pageTableRwLock.withReadLock {
            pageTable[pageLocation]
        }
        if (pageId != null) {
            pinPage(pageLocation)
            return pages[pageId]
        }
        // If the page is not in the buffer pool, we need to evict a page
        val evictedPageId = evictPage()
        // Then, we need to read the page from disk
        diskManager.readPage(pageLocation, pages[evictedPageId])
        // Finally, we need to update the page table
        pageTableRwLock.withWriteLock {
            pageTable[pageLocation] = evictedPageId
        }
        isDirty[evictedPageId] = false
        pinPage(pageLocation)
        return pages[evictedPageId]
    }

    private fun evictPage(): Int {
        logger.info { "Evicting page" }
        return evictionPolicy.evictPage()
    }

    override fun unpinPage(pageLocation: PageLocation, isDirty: Boolean) {
        logger.info { "Unpinning page $pageLocation" }
        val pageId = pageTableRwLock.withReadLock { pageTable[pageLocation] }!!
        pinCount[pageId]--
        this.isDirty[pageId] = this.isDirty[pageId] || isDirty
        evictionPolicy.pageUnpinned(pageId)
        refBit[pageId] = true
    }

    override fun flushPage(pageLocation: PageLocation) {
        logger.info { "Flushing page $pageLocation" }
        val pageId = pageTableRwLock.withReadLock { pageTable[pageLocation] }!!
        if (isDirty[pageId]) {
            diskManager.writePage(pageLocation, pages[pageId])
            isDirty[pageId] = false
        }

        freeList.addLast(pageId)
        pageTable.remove(pageLocation)

        // We don't call "evictionPolicy.pageUnpinned(pageId)" here because we are evicting the page
        // and not unpinning it
        pinCount[pageId] = 0
        isDirty[pageId] = false
        refBit[pageId] = false
    }

    override fun flushAllPages(dbId: Int) {
        logger.info { "Flushing all pages for dbId $dbId" }
        pageTableRwLock.withWriteLock {
            pageTable.keys.filter { it.dbId == dbId }.forEach { flushPage(it) }
        }
    }
}


// Accessor Methods for Heap Page memory layout
object HeapPage {
    private val logger = KotlinLogging.logger {}

    private const val PAGE_LSN_OFFSET = 0L
    private const val PAGE_ID_OFFSET = 8L
    private const val PAGE_NUM_SLOTS_OFFSET = 12L
    private const val PAGE_FREE_SPACE_OFFSET = 16L
    private const val PAGE_HEADER_SIZE = 20L
    private const val PAGE_SLOT_SIZE = 4L
    private const val PAGE_MAX_TUPLE_SIZE = PAGE_SIZE - PAGE_HEADER_SIZE - PAGE_SLOT_SIZE
    private const val DELETED_RECORD_FLAG = 0x8000.toShort()

    fun getLSN(page: MemorySegment): Long {
        return page.get(Constants.JAVA_LONG_UNALIGNED, PAGE_LSN_OFFSET)
    }

    fun setLSN(page: MemorySegment, lsn: Long) {
        page.set(Constants.JAVA_LONG_UNALIGNED, PAGE_LSN_OFFSET, lsn)
    }

    fun getPageId(page: MemorySegment): Int {
        return page.get(Constants.JAVA_INT_UNALIGNED, PAGE_ID_OFFSET)
    }

    fun setPageId(page: MemorySegment, pageId: Int) {
        page.set(Constants.JAVA_INT_UNALIGNED, PAGE_ID_OFFSET, pageId)
    }

    fun getNumSlots(page: MemorySegment): Short {
        return page.get(Constants.JAVA_SHORT_UNALIGNED, PAGE_NUM_SLOTS_OFFSET)
    }

    fun setNumSlots(page: MemorySegment, numSlots: Short) {
        page.set(Constants.JAVA_SHORT_UNALIGNED, PAGE_NUM_SLOTS_OFFSET, numSlots)
    }

    fun getFreeSpace(page: MemorySegment): Short {
        return page.get(Constants.JAVA_SHORT_UNALIGNED, PAGE_FREE_SPACE_OFFSET)
    }

    fun setFreeSpace(page: MemorySegment, freeSpace: Short) {
        page.set(Constants.JAVA_SHORT_UNALIGNED, PAGE_FREE_SPACE_OFFSET, freeSpace)
    }

    fun getSlotOffset(page: MemorySegment, slotId: Int): Short {
        return page.get(Constants.JAVA_SHORT_UNALIGNED, PAGE_HEADER_SIZE + slotId * PAGE_SLOT_SIZE)
    }

    fun setSlotOffset(page: MemorySegment, slotId: Short, offset: Short) {
        page.set(Constants.JAVA_SHORT_UNALIGNED, PAGE_HEADER_SIZE + slotId * PAGE_SLOT_SIZE, offset)
    }

    fun getSlotLength(page: MemorySegment, slotId: Int): Short {
        return page.get(Constants.JAVA_SHORT_UNALIGNED, PAGE_HEADER_SIZE + slotId * PAGE_SLOT_SIZE + 2)
    }

    fun setSlotLength(page: MemorySegment, slotId: Short, length: Short) {
        page.set(Constants.JAVA_SHORT_UNALIGNED, PAGE_HEADER_SIZE + slotId * PAGE_SLOT_SIZE + 2, length)
    }

    fun getTuple(page: MemorySegment, slotId: Int): MemorySegment {
        val offset = getSlotOffset(page, slotId)
        val length = getSlotLength(page, slotId)
        return page.asSlice(offset.toLong(), length.toLong())
    }

    fun insertTuple(page: MemorySegment, tuple: MemorySegment): RecordId {
        logger.info {
            "Inserting tuple: [page id=${getPageId(page)}, tuple size=${tuple.byteSize()}, " +
                    "free space=${getFreeSpace(page)}, num slots=${getNumSlots(page)}]"
        }

        val numSlots = getNumSlots(page)
        val freeSpace = getFreeSpace(page)
        val tupleSize = tuple.byteSize()
        if (tupleSize > PAGE_MAX_TUPLE_SIZE) {
            throw IllegalArgumentException("Tuple size is too large")
        }
        if (tupleSize > freeSpace) {
            throw IllegalArgumentException("Not enough space")
        }
        // Copy the tuple to the page
        val offset = freeSpace - tupleSize
        MemorySegment.copy(tuple, 0, page, offset, tupleSize)
        // Update the page header
        setSlotOffset(page, numSlots, offset.toShort())
        setSlotLength(page, numSlots, tupleSize.toShort())
        setNumSlots(page, (numSlots + 1).toShort())
        setFreeSpace(page, (freeSpace - tupleSize).toShort())
        return RecordId(getPageId(page), numSlots.toInt())
    }

    fun deleteTuple(page: MemorySegment, slotId: Short) {
        val freeSpace = getFreeSpace(page)
        val length = getSlotLength(page, slotId.toInt())
        // Update the page header
        setSlotOffset(page, slotId, DELETED_RECORD_FLAG)
        setSlotLength(page, slotId, 0)
        setFreeSpace(page, (freeSpace + length).toShort())
        // We clean up deleted tuples lazily, so we don't need to do anything here
    }

    fun isDeleted(page: MemorySegment, slotId: Short): Boolean {
        return getSlotOffset(page, slotId.toInt()) == DELETED_RECORD_FLAG
    }

    fun getRecordId(page: MemorySegment, slotId: Int): RecordId {
        return RecordId(getPageId(page), slotId)
    }

    fun initializeEmptyPage(page: MemorySegment, pageId: Int) {
        setLSN(page, 0)
        setPageId(page, pageId)
        setNumSlots(page, 0)
        setFreeSpace(page, PAGE_SIZE.toShort())
    }
}

class HeapFile(
    val bufferPool: IBufferPool,
    val diskManager: IDiskManager,
    val tableLocation: TableLocation,
) {
    private var numPages: Int

    private val logger = KotlinLogging.logger {}

    init {
        logger.info { "Initializing HeapFile class for table $tableLocation" }
        numPages = diskManager.getNumPages(tableLocation)

        logger.info { "Found $numPages pages in file" }
        if (numPages == 0) {
            logger.info { "Table $tableLocation is empty, creating a new page" }
            val location = getPageLocation(0)
            val page = bufferPool.fetchPage(location)
            HeapPage.initializeEmptyPage(page, 0)
            bufferPool.unpinPage(location, true)
        }
    }

    private fun getPageLocation(pageId: Int): PageLocation {
        return PageLocation(tableLocation.dbId, tableLocation.tableId, pageId)
    }

    fun deleteFile() {
        diskManager.removeTableFile(tableLocation)
    }

    fun getNumPages(): Int {
        return numPages
    }

    fun getFreeSpace(pageId: Int): Int {
        val location = getPageLocation(pageId)
        val page = bufferPool.fetchPage(location)
        val freeSpace = HeapPage.getFreeSpace(page)
        bufferPool.unpinPage(location, false)
        return freeSpace.toInt()
    }

    fun getTuple(recordId: RecordId): MemorySegment {
        val location = getPageLocation(recordId.pageId)
        val page = bufferPool.fetchPage(location)
        val tuple = HeapPage.getTuple(page, recordId.slotId)
        bufferPool.unpinPage(location, false)
        return tuple
    }

    fun insertTuple(tuple: MemorySegment): RecordId {
        logger.info { "Inserting tuple $tuple into table $tableLocation" }
        val location = getPageLocation(numPages)
        val page = bufferPool.fetchPage(location)
        // Try to insert the tuple into the page
        // Catching the exception means that the page is full, so we need to create a new page
        return try {
            val recordId = HeapPage.insertTuple(page, tuple)
            bufferPool.unpinPage(location, isDirty = true)
            recordId
        } catch (e: IllegalArgumentException) {
            bufferPool.unpinPage(location, isDirty = false)
            logger.info { "Page $location is full, creating a new page" }
            val newLocation = getPageLocation(numPages)
            val newPage = bufferPool.fetchPage(newLocation)
            HeapPage.initializeEmptyPage(newPage, numPages)
            bufferPool.unpinPage(newLocation, isDirty = true)
            numPages++
            insertTuple(tuple)
        }
    }

    fun deleteTuple(recordId: RecordId) {
        val location = getPageLocation(recordId.pageId)
        val page = bufferPool.fetchPage(location)
        HeapPage.deleteTuple(page, recordId.slotId.toShort())
        bufferPool.unpinPage(location, isDirty = true)
    }

    fun flushAllPages() {
        bufferPool.flushAllPages(dbId = tableLocation.dbId)
    }

    fun scan(
        callback: (RecordId, MemorySegment) -> Unit,
    ) {
        logger.info { "Scanning table $tableLocation with total pages: $numPages" }
        for (pageId in 0 until numPages + 1) {
            logger.info { "Scanning page $pageId" }
            val location = getPageLocation(pageId)
            val page = bufferPool.fetchPage(location)
            val numSlots = HeapPage.getNumSlots(page)
            for (slotId in 0 until numSlots) {
                if (!HeapPage.isDeleted(page, slotId.toShort())) {
                    val recordId = HeapPage.getRecordId(page, slotId)
                    val tuple = HeapPage.getTuple(page, slotId)
                    callback(recordId, tuple)
                }
            }
            bufferPool.unpinPage(location, isDirty = false)
        }
    }
}

// Free Space Map Page
// The free space map page is a special page that keeps track of the free space in each page of the table
// It is stored as a bitmap, where each 4-bit nibble represents the fullness of a single page
// The first nibble represents the first page, the second nibble represents the second page, etc.
// The free space is encoded in log2 scale, so 0 means the page is full, 1 means the page is half full, etc.
object FreeSpaceMapPage {
    const val PAGE_SIZE = 4096
    const val NUM_PAGE_ENTRIES_PER_PAGE = 2 * PAGE_SIZE // 2 per byte, 4096 bytes per page

    fun getFreeSpace(page: MemorySegment, pageId: Int): Int {
        val byteIndex = pageId / 2
        val nibbleIndex = pageId % 2
        val byte = page.get(ValueLayout.JAVA_BYTE, byteIndex.toLong())
        val nibble = if (nibbleIndex == 0) {
            byte and 0x0F // Mask out the first nibble
        } else {
            // Shift right by 4 bits to get the second nibble
            byte.toInt() shr 4 and 0x0F
        }
        return 1 shl nibble.toInt()
    }

    fun setFreeSpace(page: MemorySegment, pageId: Int, freeSpace: Int) {
        val byteIndex = pageId / 2
        val nibbleIndex = pageId % 2
        val byte = page.get(ValueLayout.JAVA_BYTE, byteIndex.toLong())
        val nibble = (Math.log(freeSpace.toDouble()) / Math.log(2.0)).toInt()
        val newByte = if (nibbleIndex == 0) {
            // Set the first nibble
            byte and 0xF0.toByte() or nibble.toByte()
        } else {
            // Set the second nibble
            byte and 0x0F or (nibble shl 4).toByte()
        }
        page.set(ValueLayout.JAVA_BYTE, byteIndex.toLong(), newByte)
    }
}

fun freeSpaceMapTest() {
    val page = MemorySegment.allocateNative(4096, MemorySession.global())
    FreeSpaceMapPage.setFreeSpace(page, 0, 1)
    FreeSpaceMapPage.setFreeSpace(page, 1, 2)

    println("FreeSpaceMapPage.getFreeSpace(page, 0) = " + FreeSpaceMapPage.getFreeSpace(page, 0))
    println("FreeSpaceMapPage.getFreeSpace(page, 1) = " + FreeSpaceMapPage.getFreeSpace(page, 1))

    // Try to set an invalid free space value
    FreeSpaceMapPage.setFreeSpace(page, 0, 9)
    // Assert it was only set to the max value
    println("FreeSpaceMapPage.getFreeSpace(page, 0) = " + FreeSpaceMapPage.getFreeSpace(page, 0))
    assert(FreeSpaceMapPage.getFreeSpace(page, 0) == 8)
}


fun bufferPoolTest() {
    val bufferPool = BufferPool(diskManager = DiskManager, evictionPolicy = ClockEvictionPolicy())
    val pageLocation = PageLocation(1, 2, 3)

    val page = bufferPool.fetchPage(pageLocation)
    page.asByteBuffer().putInt(0, 42)

    bufferPool.unpinPage(pageLocation, true)
    bufferPool.flushPage(pageLocation)

    val page2 = bufferPool.fetchPage(pageLocation)
    println(page2.asByteBuffer().int)
}

fun heapPageTest() {
    val bufferPool = BufferPool(diskManager = DiskManager, evictionPolicy = ClockEvictionPolicy())
    val pageLocation = PageLocation(1, 2, 3)

    val page = bufferPool.fetchPage(pageLocation)
    // Initialize the Heap Page free space
    HeapPage.setFreeSpace(page, PAGE_SIZE.toShort())

    // Insert a tuple
    val tuple = MemorySegment.allocateNative(4, MemorySession.global())
    tuple.asByteBuffer().putInt(0, 42)
    val recordId = HeapPage.insertTuple(page, tuple)
    bufferPool.unpinPage(pageLocation, true)

    // Get the tuple
    val page3 = bufferPool.fetchPage(pageLocation)
    val tuple2 = HeapPage.getTuple(page3, recordId.slotId)
    println("Got tuple: ${tuple2.asByteBuffer().int}")
}

fun heapFileTest() {
    val bufferPool = BufferPool(diskManager = DiskManager, evictionPolicy = ClockEvictionPolicy())

    val tuple = MemorySegment.allocateNative(4, MemorySession.global())
    tuple.asByteBuffer().putInt(0, 42)

    // Wipe the current DB_ROOT
    val dbRoot = File(DiskManager.DB_ROOT)
    dbRoot.deleteRecursively()

    // Create a HeapFile
    val heapFile = HeapFile(bufferPool, DiskManager, TableLocation(0, 0))
    assert(heapFile.getNumPages() == 1)
    assert(heapFile.getFreeSpace(0) == PAGE_SIZE)

    val recordId1 = heapFile.insertTuple(tuple)
    val recordId2 = heapFile.insertTuple(tuple)
    println("Inserted tuple at $recordId1")
    println("Inserted tuple at $recordId2")

    // Scan the HeapFile
    heapFile.scan { recordId, tuple ->
        println("Scanned tuple: ${tuple.asByteBuffer().int}")
    }

    heapFile.flushAllPages()
}

fun main() {
    heapFileTest()
    freeSpaceMapTest()
}
